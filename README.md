# Реализация MVVM для Unity проектов.

# Идея:

Реализовать архитектуру, которая бы строго разделял проект на слабо связанные слои и позволяла параллельно разрабатывать, расширять и рефакторить код.    
 
# Сущности:

- **ViewFacade** - наследник **MonoBehaviuor**, не содержит никакой логики и предоставляет доступ к сериализованным полям и компонентам GameObject-a. Один из плюсов, префабы максимально легковесные и простые для настройки. Пулиться в **GameObjectPool**.

- **ViewLogic** - связывает **ViewFacade** и **ViewModel**. Реализует визуальное поведение, установку данных в компоненты **Unity** получая доступ к ним через 

- **ViewFacade**, анимации и т.д. Обеспечивает жизненный цикл - инициализацию \ де-инициализацию. Обработку внешних события, ввод игрока, события **Unity**. Работает с интерфейсом **ViewModel** для доступа к ее публичны реактивным полям, подписываясь на события их изменения. Строгим правилом объявления этого интерфейса является указание всех публичных полей доступными только для чтения, что исключает возможность менять состояние данных отображения из логики **ViewLogic**. Работа с интерфейсом - равно слабая связанность, что позволяет сделать работу независимой и параллельной, легко менять реализацию **ViewModel**, покрывать тестами и рефакторить. Если нужно собрать комплексное поведение из уже написанных атомарных компонент **MVVM**, содержит ссылки на фабрики ( **IViewFacadeFactory**, **IViewLogicFactory** ) для их создания и обеспечивает их жизненный цикл.

- **ViewModel** - является связующим звеном между бизнес-логикой и отображением. Его задача подготовить данные бизнес-логики для корректного отображения и предоставить набор методов для выполнения команд бизнес-логики. Если нужно собрать комплексное поведение из уже написанных атомарных компонент **MVVM**, будет содержать дочерние **ViewModel**-и этих компонент.

 - **Model** - бизнес-логика и ее данные. Может быть представлена в любом виде и реализовывать любую архитектуру.
	
Все сущности и сервисы реализованы на базе интерфейсов, чтобы можно было гибко адаптировать под кастомные задачи. Все разбито на acmdef-ы. Описаны базовые тесты.
	
	
# Плюсы:
- Слабая связанность логических слоев приложения.
- Все задачи решаются по одному шаблону. UI, Meta, Core gameplay. 
- Возможность вести работу параллельно.
- Быстро вносить изменения минимально задевая другие слои.
- Удобно покрывать тестами,  писать читы и тулзы.
- Внедрять в уже существующие проекты, проводя  постепенный рефакторинг.

# Минусы:
- Требуется писать большее количество кода. Особенно для это заметно на простых вещах ( можно решить используя код-генерацию ).
- На начальном этапе - более высокий порог вхождения. Нужно понять и разобраться с данной архитектурой.
- Требуется больше времени при планировании новых задач, так  как при реализации важно декомпозировать задачу на большее количество сущностей.
	
	
# Структура проекта:

1. **Code** - содержить базовые реализации необходимых сущностей.
    1. **MVVM** - реализация паттерна.
    1. **Subscriber** - используется для автоматизации работы с событиями. Подписка \ отписка.
    1. **Pooling** - простая реализация пулла объектов.
    1. **ReactiveTypes** - реализация реактивности для свойств и коллекций.

2. **Example** - простой пример для демонстрации. Пример примитивный, не показывает всех возможностей, но демонстрирует подход в общем. Есть “карта”, на ней можно создать объекты разных типов. Карта визуализируется как в 3D, так и в UI.
    1. **Resources** - там лежат префабы. Карта и несколько объектов.
    1. **Scripts/Factories** - реализация фабрик.
        1. **PoolingViewFacadeFactory** - простой пример создания ViewFacade-ов и их пулинга.
        1. **ViewFacadesPrefabsProvider** - простой пример доступа к префаба с кешированием.
        1. **ViewLogicFactory** - простой пример создания ViewLogic.
    2. **Scripts/Init** - основная точка инициализации. В качестве DI используеться Zenject. В методе Initialize() - пример создания и работы.
    3. **Scripts/Services** - простой сервис бизнес-логики работы с картой.
        1. **IMapModel, MapObjectData** - представление данных карты. Специально реализованы максимально простыми для демонстрации отличия данных бизнес-логики от данных отображения.
        1. **IMapService** - реализует работу с картой,  создание, удаление, изменение элементов карты. Реактивность реализована примитивным образом специально.
    4. **Scripts/View** - содержит реализацию отображения.
        1. **Map** - отображение карты в 3D, создает дочерние элементы MapObject-ы.
        1. **MapObject** - отображение объекта карты в 3D.
        1. **UI** - отображение карты и элементов в интерфейсе.

